<center># 第二部分 C++程序设计</center>


本部分内容主要包括：
- [ ] 程序基本概念
- [ ] 常用数据类型
- [ ] 程序基本语句及基本程序设计
- [ ] 基本运算
- [ ] 函数与递归
- [ ] 指针思想
- [ ] 文件读写
- [ ] 类
- [ ] STL

------



# 程序基本概念



###  对于程序的理解

既然是要学习程序设计竞赛，那么我们要先了解一下什么是程序。

程序（program）可以看作一系列可执行指令的集合，这些指令主要包括：

- 输入（Input）：获取数据；
- 输出（Output）：把数据显示到屏幕上或存入一个文件等；
- 运算：执行最基本的运算（基本数学运算如加减乘除、位运算等）和数据存储；
- 判断和分支：判断某个条件，根据判断结果执行不同命令；
- 循环：重复执行一系列操作。

以上这些指令的详解将会在本部分后续章节给出。

比如说我们思考一个非常简单的例子：

> 输入两个数 $a, b$ ，交换 $a$ 和 $b$ 的值后输出。

那么我们这个程序可以分为三步：

1. 输入：输入 $a$ 和 $b$
2. 运算：新建一个变量 $c$ ，令 $c$ 赋值为 $a$；接着，令 $a = b, b = c$；
3. 输出：输出运算后的 $a$ 和 $b$。

其实我们看到那些高大上的代码本质上也是由一个个可执行的指令组合而成。其实很多时候我们抱怨这题一秒钟切但是代码实现好难，并不是因为这题毒瘤还是什么的，还是因为我们自己的思路不够清晰。每一步的命令就这么几种，理清思路，题目自然能迎刃而解。



### 一些基本概念

#### 变量
- 变量的作用：方便我们管理内存空间

- 变量使用语法
  ```cpp
  数据类型  变量名 = 变量初始值；
  示例：
  int a = 10;
  
  cout << "a = " << a << endl;
  ```
  释义：创建变量 a ，输出内容为变量 a 的值。

#### 常量
- 常量的作用：用于记录程序中不可更改的数据
- #define 宏常量使用语法
  ```cpp
  #define 常量名 常量值
  
  宏常量通常定义在最上方
  ```
  释义：#define 通常在文件上方定义，表示一个常量
- const 修饰的常量使用语法
  ```cpp
  const 数据类型 常量名 = 常量值
  
  修饰变量位置可在最上方也可在调用处上方
  ```
  释义：const通常在变量定义前加关键字const，修饰该变量为常量，不可修改
- 示例：
  ```cpp
  #define Day 365
  
  const int month = 12；
  ```
#### 关键字
- 不要用关键字给变量或常量起名称，否则会产生歧义。

| asm       | auto         | bool        | break            | case     | catch    | char    |
|-----------|--------------|-------------|------------------|----------|----------|---------|
| class     | const        | const_cast  | continue         | default  | delete   | do      |
| double    | dynamic_cast | else        | enum             | explicit | export   | extern  |
| false     | float        | for         | friend           | goto     | if       | inline  |
| int       | long         | mutable     | namespace        | new      | operator | private |
| protected | public       | register    | reinterpret_cast | return   | short    | signed  |
| sizeof    | static       | static_cast | struct           | switch   | template | this    |
| throw     | true         | try         | typedef          | typeid   | typename | union   |
| unsigned  | using        | virtual     | void             | volatile | wchar_t  | while   |

#### 标识符命名规则
- 标识符作用：给变量、常量命名
  - 标识符不能是关键字
  - 标识符只能由字母、数字、下划线组成
  - 第一个字符必须为字母或下划线
  - 标识符中字母区分大小写

------

# 数据类型

什么是数据类型？数据类型指的是可以在程序中存储和操作的值的类型，每种编程语言都有其支持的数据类型，不同的数据类型用来存储不同的数据，例如文本、数值、图像等。

C++语言不仅为我们提供了 `int，double `等基本数据类型，还为我们提供了如数组、结构体等构造类型，以及指针类型、空类型等其他数据类型。



## 基本数据类型

常用基本数据类型主要有以下几种：

##### 整型：

整型变量表示的是整数类型的数据。C++中能够表示整型的类型有以下几种方式，区别在于所占内存空间不同：

| 数据类型             | 占用空间                                            | 取值范围              |
| :------------------- | :-------------------------------------------------- | :-------------------- |
| short（短整数）      | 2字节                                               | $-2^{15}$ ~$2^{15}-1$ |
| int（整型）          | 4字节                                               | $-2^{31}$ ~$2^{31}-1$ |
| long（长整型）       | Windows为4字节，Linux为4字节（32位），8字节（64位） | $-2^{31}$ ~$2^{31}-1$ |
| long long (长长整型) | 8字节                                               | $-2^{63}$ ~$2^{63}-1$ |

数据在计算机中的存储都遵循我们在第一部分所提到的以补码形式存储，那么我们想想如果我们要存储的这个数超出了这个数据类型的存储范围会怎么样呢？

我们可以试着定义一个 `int` 类型的数，赋值为 $2^{31}$ ，再将其输出，我们会发现它会输出 $-2147483648$，也就是 $-2^{31}$ ，这是为什么呢？将 $2^{31}$ 用补码表示出来，即为 $010000...(1后面有31个0)$ ，这一共有 $33$ 位，然而 int 类型只能存储 $32$ 位，所以计算机只能保留后面那 $32$ 位而舍后面31去前面的，那么现在就成了 $1000...(1后面31个0)$ ，而这其实是 $-2^{31}$ 的补码表示。

这是对于有符号整数的，那么对于无符号整数 （如 `unsigned int long long`）呢？无符号整数自然是不必考虑符号的问题，若是溢出依然是保留后面几位，如 `unsigned long long`  溢出其实就相当于对 $2^{64}$ 取模。

##### sizeof关键字

- 作用：利用sizeof关键字可以统计数据类型所占内存大小

- 语法

  ```cpp
  sizeof（数据类型 / 变量）
  ```

- 示例：

  ```cpp
  int main() {
    short a = 10;
    int b =11;
    long c = 12;
    long long d = 13;
    cout << "short 类型所占内存空间为：" << sizeof(short) << endl;
    cout << "int 类型所占内存空间为：" << sizeof(int) << endl;
    cout << "long 类型所占内存空间为：" << sizeof(long) << endl;
    cout << "long long 类型所占内存空间为：" << sizeof(long long) << endl;
    system("pause");
    system("cls");   //清屏操作
    return 0;
  }
  ```

$sizeof$在程序设计竞赛中常用的一个地方是对于整个数组的初始化：

```cpp
memset(a, 0, sizeof(a));
```

##### 浮点型

浮点型，即为小数类型。一般浮点数数据类型由符号位、指数位、尾数位组成。浮点数的范围由符号位决定，精度则由指数位决定。

**float**：占32位，其中符号位 $1bit$ ，指数位 $8bits$，尾数位 $23bits$，范围 $-3.40E+38$ ~ $+3.40E+38$。

**double**：占64位，其中符号位 $1bits$，指数位 $11bits$，尾数位 $53bits$，范围 $-1.79E+308$ ~ $+1.79E+308$

 **long double**：占96位，范围：$ 1.18973e+4932$ ~ $3.3621e-4932$。特别注意，long double在使用库函数时要在函数后面加个l。

默认情况下输出小数时都是输出 6 位有效数字

##### 字符型

字符型变量用于显示单个字符。

```cpp
char c = 'a';
```

需要注意是，单个字符用单引号。

字符型变量只占 1 字节，存储时并不是直接存储这个字符而是存储这个字符的 ASCII 码。

ASCII (American Standard Code for Information Interchange)：美国信息交换标准代码是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。它是最通用的信息交换标准，并等同于国际标准 ISO/IEC 646，ASCII码到目前为止共定义了128个字符，正好是 1 字节，这就是字符型只占 1 字节的原因。

完整的ASCII码如下：

| **ASCII值** | **控制字符** | **ASCII值** | **控制字符** | **ASCII值** | **控制字符** | **ASCII值** | **控制字符** |
| ----------- | ------------ | ----------- | ------------ | ----------- | ------------ | ----------- | ------------ |
| 0           | NUL          | 32          | (space)      | 64          | @            | 96          | 、           |
| 1           | SOH          | 33          | ！           | 65          | A            | 97          | a            |
| 2           | STX          | 34          | ”            | 66          | B            | 98          | b            |
| 3           | ETX          | 35          | #            | 67          | C            | 99          | c            |
| 4           | EOT          | 36          | $            | 68          | D            | 100         | d            |
| 5           | ENQ          | 37          | %            | 69          | E            | 101         | e            |
| 6           | ACK          | 38          | &            | 70          | F            | 102         | f            |
| 7           | BEL          | 39          | '            | 71          | G            | 103         | g            |
| 8           | BS           | 40          | (            | 72          | H            | 104         | h            |
| 9           | HT           | 41          | )            | 73          | I            | 105         | i            |
| 10          | LF           | 42          | *            | 74          | J            | 106         | j            |
| 11          | VT           | 43          | +            | 75          | K            | 107         | k            |
| 12          | FF           | 44          | ,            | 76          | L            | 108         | l            |
| 13          | CR           | 45          | -            | 77          | M            | 109         | m            |
| 14          | SO           | 46          | .            | 78          | N            | 110         | n            |
| 15          | SI           | 47          | /            | 79          | O            | 111         | o            |
| 16          | DLE          | 48          | 0            | 80          | P            | 112         | p            |
| 17          | DCI          | 49          | 1            | 81          | Q            | 113         | q            |
| 18          | DC2          | 50          | 2            | 82          | R            | 114         | r            |
| 19          | DC3          | 51          | 3            | 83          | X            | 115         | s            |
| 20          | DC4          | 52          | 4            | 84          | T            | 116         | t            |
| 21          | NAK          | 53          | 5            | 85          | U            | 117         | u            |
| 22          | SYN          | 54          | 6            | 86          | V            | 118         | v            |
| 23          | TB           | 55          | 7            | 87          | W            | 119         | w            |
| 24          | CAN          | 56          | 8            | 88          | X            | 120         | x            |
| 25          | EM           | 57          | 9            | 89          | Y            | 121         | y            |
| 26          | SUB          | 58          | :            | 90          | Z            | 122         | z            |
| 27          | ESC          | 59          | ;            | 91          | [            | 123         | {            |
| 28          | FS           | 60          | <            | 92          | \            | 124         | \|           |
| 29          | GS           | 61          | =            | 93          | ]            | 125         | }            |
| 30          | RS           | 62          | >            | 94          | ^            | 126         | ~            |
| 31          | US           | 63          | ?            | 95          | —            | 127         | DEL          |

其中，前面的 31 个字符都是控制字符，用于控制打印机等一些外围设备，我们一般不需理解它是什么意思，感兴趣的同学可以自行上网查阅。

##### 字符串型

作用：用于表示一串字符

注意：字符串值需要用双引号 "" 包含起来，与字符使用的单引号 '' 做区分。

C风格字符串：`char 变量名[] = "字符串值"；`

示例：

```cpp
int main() {
  char str1[] = "hello-world";   //C风格字符串需要在变量名后面加中括号 []
  cout << str1 << endl;
  system("pause");
  return 0;
}
```

C++风格字符串：string 变量名 = "字符串值"；

示例：

```cpp
#include<string>   //用C++风格字符串时候，要引用这个头文件
int main() {
  string str2 = "hello-world";
  cout << str2 << endl;
  system("pause");
  return 0;
}
```

##### bool型

作用：布尔数据类型代表真或假的值

`bool`类型只有两个值：true --- 真（本质是1；false --- 假（本质是0）

`bool`类型占1个字节大小

```cpp
int a = 1;
bool flag = (a > 0);
cout << flag;
//输出1
```

我们已经知道，bool类型只需要两个值：1和0，这样的话应该只占1位，然而实际上`bool`型却占了4位，剩下的 126 个值是干什么的呢？实际上，这并没有什么用，反而占了许多空间。那么对于有的题，空间比较紧张，如果我们用 bool 型而浪费了许多空间而 MLE(Time Limit Exceeded)，这岂不是一件可能遗恨千古的事吗（尤其是在考场上）。

那么，`bitset`便派上了用场。

C++的 bitset 在 bitset 头文件中，它是一种类似数组的结构，它的每一个元素只能是０或１，每个元素仅用１bit空间。

由于内存地址是按字节即 `byte` 寻址，而非比特 `bit`，一个 `bool` 类型的变量，虽然只能表示 `0/1`, 但是也占了 1 byte 的内存。

`bitset` 就是通过固定的优化，使得一个字节的八个比特能分别储存 8 位的 `0/1`。

对于一个 4 字节的 `int` 变量，在只存 `0/1` 的意义下，`bitset` 占用空间只是其$\frac{1}{32}$，计算一些信息时，所需时间也是其$\frac{1}{32}$。

bitset常用构造函数有四种，如下

```cpp
    bitset<4> bitset1;　　//无参构造，长度为４，默认每一位为０

    bitset<8> bitset2(12);　　//长度为８，二进制保存，前面用０补充

    string s = "100101";
    bitset<10> bitset3(s);　　//长度为10，前面用０补充
    
    char s2[] = "10101";
    bitset<13> bitset4(s2);　　//长度为13，前面用０补充

    cout << bitset1 << endl;　　//0000
    cout << bitset2 << endl;　　//00001100
    cout << bitset3 << endl;　　//0000100101
    cout << bitset4 << endl;　　//0000000010101
```

那么现在我们就可以将 `bitset` 当作一个`bool`数组用了，我们来看看改动这个“数组”的值的操作：

- `operator []`: 访问其特定的一位。
- `operator ==/!=`: 比较两个 `bitset` 内容是否完全一样。
- `operator &/&=/|/| =/^/^=/~`: 进行按位与/或/异或/取反操作。

其他操作我们后面在详细讲解`bitset` 时会提到。



## 构造类型

构造类型，即由基本数据类型组合而来。

### 数组

概述：数组时一个集合，里面存放了相同类型的数据元素

特点：

  - 数组中的每个数据元素都是相同的数据类型
  - 数组是由连续的内存位置组成的

#### 一维数组

##### 一维数组定义方式

  一维数组定义的三种方式：

  - 数据类型 数组名[数组长度];

  - 数据类型 数组名[数组长度] = {值1,值2,...};

  - 数据类型 数组名[] = {值1,值2,...};

- 示例：

  ```cpp
  using namespace std;
  int main(){
    //数据类型 数组名[数组长度];
    int arr[5];
    //给数组中的元素进行赋值
    //数组元素的下标时从0开始索引的
    arr[0] = 10;
    arr[0] = 20;
    arr[0] = 30;
    arr[0] = 40;
    arr[0] = 50;
    //访问数据元素
    cout << arr[0] << endl;
  
    //数据类型 数组名[数组长度] = {值1,值2,...};
    //如果在初始化数据的时候，没有全部填写完，会用0填补剩余数据
    int arr2[5] = {100,200,300};
    //利用循环输出数组中的元素
    for (int i = 0; i < 5; i++){
      cout << arr2[i] << endl;
    }
  
    //数据类型 数组名[] = {值1,值2,...};
    //定义数组的时候，必须有初始的长度
    int arr3[] = {90,80,70,60,50,40,30,20,10};
    for (int j = 0; j < 9; j++){
      cout << arr3[j] << endl;
    }
  
    system("pause");
    return 0;
  }
  ```

  注意1：数组名的命名规范与变量名命名规范一致，不要和变量重名
  注意2：数组中下标是从0开始索引

##### 一维数组数组名

  一维数组名称的用途：

  - 可以统计整个数组在内存中的长度

    ```cpp
    sizeof(arr)
    sizeof(arr[0])
    ```

  - 可以获取数组在内存中的首地址

    ```cpp
    cout << arr << endl;
    ```

- 示例：

  ```cpp
  using namespace std;
  int main(){
  
    //可以统计整个数组在内存中的长度
    int arr[10] = {1,2,3,4,5,6,7,8,9,10};
    cout << "整个数组占用内存空间为：" << sizeof(arr) << endl;
    cout << "每个元素占用内存空间：" << sizeof(arr[0]) << endl;
    cout << "数组中元素个数为：" << sizeof(arr) / sizeof(arr[0]) << endl;
  
    //可以获取数组在内存中的首地址
    cout << "数组首地址为：" << arr << endl;    //输出十六进制的内存地址
    cout << "数组首地址为：" << (int)arr << endl; //输出十进制的内存地址
    cout << "数组中第一个元素地址为：" << (int)&arr[0] << endl; 
  
    //数组名是常量，不可以进行赋值操作
  
    system("pause");
    return 0;
  }
  ```

  案例：五只小猪称重
  要求：在一个数组中记录五只小猪的体重，找出并打印最重的小猪体重。

  ```cpp
  using namespace std;
  int main(){
  
    //创建五只小猪体重的数组
    int arr[5] = {300,350,200,400,250};
  
    //从数组中找到最大值
    int max = 0;    //先认定一个最大值为0
  
    for (int i = 0; i < 5; i++){
      //如果访问的数组中的元素比 max 的值还要大，更新 max 值
      if (arr[i] > max){
        max = arr[i]; 
      }
    }
  
    //打印最大值
    cout << "最重的小猪体重为：" << max << endl;
  
    system("pause");
    return 0;
  }
  ```

  案例2：数组元素逆置
  要求：请声明一个5元素的数组，并且将元素逆置

  ```cpp
  using namespace std;
  int main(){
  
    //实现数组元素逆置
    //创建数组
    int arr[5] = {1,3,2,5,4};
    cout << "数组逆置前：" << endl;
    for (int i = 0; i <5; i++){
      cout << arr[i] << endl;
    }
  
    //实现逆置
    //记录起始下标位置
    int start = 0;
  
    //记录结束下标位置
    int end = sizeof(arr)/sizeof(arr[0]) - 1; //末尾元素下标
  
    while (start < end) {
  
    //起始下标与结束下标的元素互换
    int temp = arr[start];
    arr[start] = arr[end];
    arr[end] = temp;
  
    //起始位置++，结束位置--。下标更新
    start++;
    end--;
    }
    //循环执行操作，直到起止位置 >= 结束位置
    cout << "数组逆置后：" << endl;
    for (int i = 0; i <5; i++){
      cout << arr[i] << endl;
    }
  
    system("pause");
    return 0;
  }
  ```

#### 二维数组

二维数组就是在一维数组上多加一个维度

二维数组定义方式：

  - 数据类型 数组名[行数][列数];

  - 数据类型 数组名[行数][列数] = {{数据1,数据2} , {数据3,数据4}};

  - 数据类型 数组名[行数][列数] = {数据1,数据2,数据3,数据4};

  - 数据类型 数组名[  ][列数] = {数据1,数据2,数据3,数据4};

示例：

```cpp
using namespace std;
int main(){
  
  //数据类型 数组名[行数][列数];
  int arr[2][3];
  arr[0][0] = 1;
  arr[0][1] = 2;
  arr[0][2] = 3;
  arr[1][0] = 4;
  arr[1][1] = 5;
  arr[1][2] = 6;

  //输出二维数组元素值
  for (int i = 0; i < (sizeof(arr)/sizeof(arr[0][0])/3); i++){
    for (int j = 0; j < (sizeof(arr)/sizeof(arr[0][0])/2); j++){
      cout << arr[i][j] << endl;
    }
}
    //数据类型 数组名[行数][列数] = {{数据1,数据2} , {数据3,数据4}}; 
    int arr2[2][3] = {
      {1,2,3},
      {4,5,6}
    };
    for (int i = 0; i < (sizeof(arr2)/sizeof(arr2[0][0])/3); i++){
      for (int j = 0; j < (sizeof(arr2)/sizeof(arr2[0][0])/2); j++){
        cout << arr2[i][j] << " " ;
      }
      cout << endl;
    }

    //数据类型 数组名[行数][列数] = {数据1,数据2,数据3,数据4};
    int arr3[2][3] = {1,2,3,4,5,6};
    for (int i = 0; i < (sizeof(arr3)/sizeof(arr3[0][0])/3); i++){
      for (int j = 0; j < (sizeof(arr3)/sizeof(arr3[0][0])/2); j++){
        cout << arr3[i][j] << " " ;
      }
      cout << endl;
    }

    //数据类型 数组名[  ][列数] = {数据1,数据2,数据3,数据4};
    int arr4[][3] = {1,2,3,4,5,6};
    for (int i = 0; i < (sizeof(arr4)/sizeof(arr4[0][0])/3); i++){
      for (int j = 0; j < (sizeof(arr4)/sizeof(arr4[0][0])/2); j++){
        cout << arr4[i][j] << " " ;
      }
      cout << endl;
    }

    system("pause");
    return 0;
}
```

#### 二维数组数组名
  - 查看二维数组所占内存空间

  - 获取二维数组首地址

示例：

  ```cpp
  using namespace std;
  int main(){
    //查看占用内存空间大小
    int arr[2][3] = {
      {1,2,3},
      {4,5,6}
    };
    cout << "二维数组占用内存空间为：" << (sizeof(arr)) << endl;
    cout << "二维数组第一行占用内存空间为：" << sizeof(arr[0]) << endl; //arr[0]表示第一行
  
    //查看二维数组首地址
    cout << "二维数组首地址为：" << arr << endl;
  
    system("pause");
    return 0;
  }
  ```

数组的可以用来表示形象的，如二维数组可以很自然地表示地图；也可以表示抽象的，来存储、记录一些状态等，如在遍历图时开一个 $vis$ 数组记录这个节点是否走过，再如动态规划记录已经走过状态的最优解等。之后用到数组的地方非常多，可能不止一维、两维，更高维的数组以一维、两维数组类推即可。

### 结构体

结构体属于**用户自定义的数据类型**，允许用户存储不同的数据类型。

> JYOI举行了一场NOIP赛前模拟赛，为了更好地找到 JYOIers 中隐藏的巨佬，分析大家擅长的题型，现在需要你保存几位 JYOIers 的姓名、考号、考试成绩、T1得分、T2得分、T3得分、T4得分。

很显然，这直接用我们上一节所讲的数组就行了，如下：

```cpp
string name[8]，number[8];
int sc[8], T1[8], T2[8], T3[8], T4[8];
```

但是如果你是一个十分在意细节的人，你会发现：

- 首先，这样好乱；
- 其次，这似乎是以姓名、考号等信息为中心的，而不是以选手为中心的。

所以，结构体应运而生：

```cpp
struct jyoier {
    string name, number;
    int sc, t1, t2, t3, t4;
}a[8];
```

这样，数组中每个元素都有 $name, number, sc, t1, t2, t3, t4$ 这四种信息，而数组的定义是每个元素都是一种数据类型，那么，现在的 $a$ 数组是什么数据类型的呢？整形？字符串型？都不是，而是我们自己定义的 $jyoier$ 型。

通过结构体创建变量的方式有三种：

-  struct 结构体名 变量名；
-  struct 结构体名 变量名 = {成员1值，成员2值...};
-  定义结构体时顺便创建变量；
- 通过构造函数的方法。

其中第二种方法不建议用，这种奇怪的语法虽然能编译过但C++已经更新多次，不太常用了。如果要用第二种语法，那么在传成员值时类型一定要一一对应，据悉，2022年CSP-S便有一名选手因上传成员值类型没有对应而造成CE惨案。

下面来讲一下**构造函数**的方法。

构造函数是一类较为特别的成员函数，它必须先声明在结构体的内部，**其函数名与该结构体类型的名字一样**，如此处结构体类型名为 $jyoier$，则构造函数的名字便为 $jyoier$。另外，构造函数**没有返回值**，不需要用户调用（用户也无法调用），而是在创建对象时**自动执行**。

我们可以用构造函数来初始化：

```cpp
struct jyoier {
    string name, number;
    int sc, t1, t2, t3, t4;
    jyoier() {
        name = "xjz", number = "HE-01";
        sc = 400, t1 = 100, t2 = 100, t3 = 100, t4 = 100;
    }
}a[8];
```

构造函数可以与其他函数一样传入参数，根据参数来进行初始化，在调用时必须在定义结构体类型的变量时同时传入参数。

```cpp
struct jyoier {
    string name, number;
    int sc, t1, t2, t3, t4;
    jyoier(string s1, string s2, int sum, int a, int b, int c, int d) {
        name = s1, number = s2;
        sc = sum, t1 = a, t2 = b, t3 = c, t4 = d;
    }
}
jyoier lsy("lsy", "HE-02", 400, 100, 100, 100, 100);
```

那么，结构体除了让你的代码更整齐、更有逻辑一些，还有什么用呢？

> 就在 JYOIer 们正在讨论模拟赛成绩时，xjz老师来了，他想知道按总分为关键字的排名。

这样的话，如果我们应用了结构体，那么将是一个非常优雅的排序过程：

```cpp
bool cmp(jyoier x, jyoier y) {
    return x,sc > y.sc;
}
sort(a + 1, a + 8, cmp);
```

当然，用上重载函数会更加优雅：

```cpp
struct jyoier {
    string name, number;
    int sc, t1, t2, t3, t4;
    bool operator < (const jyoier &x) const {
        return x.sc < sc;
    }
}a[8];
sort(a + 1, a + 8, cmp);
```

重载运算符是通过对运算符的重新定义，使得其支持特定数据类型的运算操作。重载运算符是重载函数的特殊情况。

C++ 自带的运算符，最初只定义了一些基本类型的运算规则。当我们要在用户自定义的数据类型上使用这些运算符时，就需要定义运算符在这些特定类型上的运算方式。我们在接下来的章节中也会有重载函数的详解。

### 指针

指针描述了数据在内存中的位置，标示了一个占据存储空间的实体，在这一段空间起始位置的相对距离值。在 C/C++语言中，指针一般被认为是指针变量，指针变量的内容存储的是其指向的对象的首地址，指向的对象可以是变量（指针变量也是变量），数组，函数等占据存储空间的实体。

指针作用：可以通过指针间接访问内存

 - 内存编号是从0开始记录的，一般用十六进制数字表示

 - 可以利用指针变量保存地址

 #### 指针变量的定义和使用
- 示例：
  ```cpp
  using namespace std;
  int main(){
  
    //定义指针
    int a = 10;
  
    //指针定义的语法：数据类型 * 指针变量名
    int * p;
  
    //让指针记录变量 a 的地址
    p = &a;
    cout << "a的地址为：" << &a << endl;
    cout << "a的地址为：" << p << endl;
  
    //使用指针
    //可以通过解引用的方式来找到指针指向的内存
    //指针前加 * 代表解引用，找到指针指向的内存中的数据
    *p = 1000;
    cout << "a = " << a << endl;
    cout << "*p = " << *p << endl;
  
    system("pause");
    return 0;
  }
  ```
#### 指针所占内存空间
- 指针也是一种数据类型。
- 示例：
  ```cpp
  using namespace std;
  int main(){
  
    int a = 10;
  
    int * p;
    p = &a;  //指针指向数据a的地址
    //在32位操作系统下，占用4个字节空间
    //在64位操作系统下，占用8个字节空间
    
    cout << "sizeof(int *) = " << sizeof(p) << endl;
    cout << *p << endl;  //解引用
    cout << sizeof(p) << endl;
    cout << sizeof(char *) << endl;
    cout << sizeof(flot *) << endl;
    cout << sizeof(double *) << endl;
  
    system("pause");
    return 0;
  }
  ```
#### 空指针和野指针
- 空指针：指针变量指向内存中编号为0的空间
- 用途：初始化指针变量
- 注意：空指针指向的内存是不可以访问的
- 示例：
  ```cpp
  using namespace std;
  int main(){
    //空指针用于给指针变量进行初始化
    int * p = NULL;
    //空指针是不可以进行访问的 
    //0~255之间的内存编号是系统占用的，因此不可以访问
    *p = 1000;  //报错：写入权限冲突
    system("pause");
    return 0;
  }
  ```
- 野指针：指针变量指向非法的内存空间
- 示例：
  ```cpp
  using namespace std;
  int main(){
    //野指针变量p指向内存地址编号为0x1100的空间
    //在程序中，尽量避免出现野指针
    int * p = (int *)0x1100;
  
    //访问野指针报错
    cout << *p << endl;
  
    system("pause");
    return 0;
  }
  ```
#### const修饰指针
- const 修饰指针有三种情况：
  - const修饰指针---常量指针
  - const修饰常量---指针常量
  - const即修饰指针，又修饰常量
- 示例：
  ```cpp
  using namespace std;
  int main(){
  
    int a = 10;
    int b = 10;
  
    //const修饰的是指针，指针指向可以改，指针指向的值不可以更改
    //常量指针
    const int * p1 = &a;
    p1 = &b;  //正确
    *p1 = 100;  //错误
  
    //const修饰的是常量，指针指向不可以改，指针指向的值可以改
    //指针常量
    int * const p2 = &a;
    p2 = &b;  //错误
    *p2 = 20;  //正确
  
    //const即修饰指针又修饰常量，指针的指向和指针指向的值都不可以改
    const int * const p3 = &a;
    *p3 = 20;  //错误
    p3 = &b;   //错误
    *p3 = 10;  //正确

    system("pause");
    return 0;
  }
  ```
#### 指针和数组
- 作用：利用指针访问数组中元素
- 示例：
  ```cpp
  using namespace std;
  int main(){

    //指针和数组
    //利用指针访问数组中的元素

    int arr[10] = {1,2,3,4,5,6,7,8,9,10};
    cout << "第一个元素为：" << arr[0] << endl;

    int * p = arr; //arr就是数组的首地址

    cout << "利用指针访问第一个元素：" << *p << endl;

    p++;  //让指针向后偏移4个字节 
    cout << "利用指针访问第二个元素：" << *p << endl;

    cout << "利用指针遍历数组" << endl;
    int * p2 = arr;
    for (int i = 0; i < 10; i++){
      cout << arr[i] << endl;
      cout << *p2 << endl;
      p2++;
    }

    system("pause");
    return 0;
  }
  ```
#### 指针和函数
- 作用：利用指针作函数参数，可以修改实参的值
- 示例：
  ```cpp
  using namespace std;
  
  //实现两个数字进行交换
  void swap01(int a,int b){
    int temp = a;
    a = b;
    b = temp;
  
    cout << "swap01 a = " << a << endl;
    cout << "swap01 b = " << b << endl;
  }
  
  void swap02(int *p1,int *p2){
    int temp = *p1;
    *p1 = *p2;
    *p2 = temp;
  }
  
  int main(){
  
    //指针和函数
    //值传递
    int a = 10;
    int b = 20;
    swap01(a,b);
  
    //地址传递
    //如果是地址传递，可以修饰实参
    swap02(&a,&b);   
  
    cout << "a = " << a << endl;
    cout << "b = " << b << endl;
  
    //
  
    system("pause");
    return 0;
  }
  ```
#### 指针、数组、函数
- 案例：封装一个函数，利用冒泡排序，实现对整型数组的升序排序
- 例如：int arr[10] = {4,3,6,9,1,2,10,8,7,5};
- 示例：
  ```cpp
  //冒泡排序函数：参数1是数组的首地址，参数2是数组的长度 
  void bubbleSort(int * arr,int len)   //int * arr 也可以写作int arr[]
  {
    for (int i = 0; i < len; i++){
      for (int j = 0; j < len - 1 -i; j++){
        if (arr[j] > arr[j+1]){
          int temp = arr[j];
          arr[j] = arr[j + 1];
          arr[j + 1] = temp;
        }
      }
    }
  }
  
  //打印数组
  void printArray(int * arr, int len)
  {
    for (int i = 0; i < len; i++){
      cout << arr[i] << endl;
    }
  }
  
  int main(){
  
    //创建一个数组
    int arr[10] = {4,3,6,9,1,2,10,8,7,5};
  
    //数组长度
    int len = sizeof(arr) / sizeof(arr[0]);
  
    //创建函数，实现冒泡排序
    bubbleSort(arr, len)
  
    //打印排序后的数组
    printArray(arr, len);
  
    system("pause");
    return 0;
  }
  
